---
title: 算法基础
author: 菲尼莫斯
date: 2019-02-19
tags:
- 算法
categories:
- utils
---

# 算法基础

by 菲尼莫斯  2019年02月19日

---

## 链表

```js
class LinkNode {
    value = null;
    next = null;
    push(value) {
        const temp = new LinkNode();
        temp.value = value;
        this.getLast().next = temp;
    }
}
```

## 二叉树

深度为k的完全二叉树：

* 第k-1层节点数达到最大，整棵树无单独的右子节点

    1. 第i层（i ≠ k）： 具有2 <sup>i-1</sup> 个节点

    2. 最多具有2<sup>k</sup>-1个节点

    3. 度（孩子数）为0的节点是度为2的节点的两倍

    4. n个节点的完全二叉树有 n/2 + n mod(2) 个叶子节点

* 将完全二叉树按照从上到下，从左到右，从1开始编号则有：

    1. 编号为i的节点的父节点编号为i/2（向下取整）

    2. 编号为i的节点的左子节点编号为2i

* 二叉树常用算法：

    1. 首先根据所给的二叉树数组判断出根节点的位置

    2. 找出根节点的左子树和右子树数组

    3. 对左右子树进行递归处理

## 堆（大堆，小堆）

* 堆是一个完全二叉树

* 堆本质上是无序的，但满足根总比左右子节点大（小）

* 堆可以用数组表示，对于数组中第i个元素来说

    * 其父节点为第`floor(i/2)`个元素

    * 其左子节点为第`2i + 1`个元素

    * 其右子节点为第`2i + 2`个元素

* shiftUp(node): 如果一个节点比它的父节点大（最大堆）或者小（最小堆），那么需要将它同父节点交换位置。

* shiftDown(node): 如果一个节点比它的子节点小（最大堆）或者大（最小堆），那么需要将它向下移动。

* insert(node)：将一个元素插入到数组最后方，之后调用shiftUp(lastNode)进行排序

* remove(node)：删除一个元素，之后将最后一个元素移至被删除位置，调用shiftDown(removeNode)方法来堆化

## 栈

## 向量

## Hash Map

### Hash冲突的解决方法：

**开放定址法：**

要求哈希表的长度必须大于需要存放数据的长度。

若插入一个数据时在哈希表中发生了冲突，便从这个发生冲突的单元开始，按照一定的规则找到这张哈希表中其他的可用空间进行数据存放（当然，这块被占用的空间以后也会发生冲突）。

寻找可用空间的算法有三种：

1. 线行探测法：直接取冲突位置的下一个空间，若表到底，则重新从表头开始，直到找到一个空闲的空间或者探测完毕

2. 平方探测法：将冲突的空加上 1²、 2²等。即d[i] + 1²，d[i] + 2², d[i] + 3²...直到找到空闲单元。


## 算法

* 搜索（广度、深度）

* 递归

尤其是对树和数组的处理时

考虑处理到中间一步时的情况 （如n轮排序中的第i轮，0 \< i \< n）

假设该部分之前的数据已经全部处理完成（如第i轮排序，i之前的部分已经全部为有序）

此时只需考虑怎么将这一步和之前完成的部分结合起来并开启下一部分（如将第i轮排好序）

* 二分查找

* 排序（归并、快排、冒泡）

* 树的增删改查遍历

* 图论

用二维数组来表示一个图，每个值表示每个节点间的连通性

1表示连通，0表示不连通

|   | A | B | C |
| - | - | - | - |
| **A** | 0 | 1 | 1 |
| **B** | 1 | 0 | 1 |
| **C** | 1 | 1 | 0 |


* Hash算法

* 分治法（模块化）

* 动态规划

运用函数f（x，y）来表示某些情况下的状态（x，y）下的取值，运用函数和数据的关联性，在（x，y）的取值范围内算出所有结果

## 系统设计

* 不涉及高并发的大规模分布式系统技术：

谷歌的GFS、MapReduce、Bigtable技术（Hadoop、HBase、HDFS、Cassandra）

* 传统大规模分布式系统：

database + sharding（分片） + cache

sharding的水平分片和垂直分片

cache的同步和异步更新

* 数据库：

SQL：MySql、SqlServer、oracle

NoSql：Redis/TFS、monogoDB、levelDB

## 链表判环

1. 设置一个块遍历fast，一个慢遍历slow

2. fast每次移动2步，slow每次移动1步

3. 若fast和slow最终相交则证明有环存在

4. 从链表头设置一个新遍历its

5. its每次移动1步，slow继续遍历每次移动1步

6. its和slow必相交，且交点为环的入口点

* 引申： 判断两条链是否相交，并找到交点： （将链尾连到链头形成环）

## 寻找公共子串

采用滑动比较法


