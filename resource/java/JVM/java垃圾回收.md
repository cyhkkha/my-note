

# java垃圾回收

by 菲尼莫斯 2019年3月14日

---

（待完善）

## 回收对象

* 离开了作用域的对象

* 无引用指向的对象

## 可达性分析算法

* 以一个根节点（GC Root）开始，进行引用搜索，形成一条引用链，若一个节点与根节点不存在引用链，则将该节点视为垃圾

* 可以作为根节点的对象为：虚拟机栈或方法栈中引用的对象、方法区的静态属性和常量引用的对象

* 引用类型分为：强引用（new直接引用）、软引用（数组引用等，在内存溢出前一直存在）、弱引用（类似于软引用，会在第二次垃圾回收时回收）、虚引用（类似于软引用，但会被直接回收且无法访问）

* 标记-清除算法：每次先标记出需要回收的内存，在清理时清除标记的内容，容易产生内存碎片
    * 复制算法改进：每次清理前，将未标记的对象复制到一块干净的内存，一次性清理以前已使用的全部内存，但会是内存使用率降低
    * 标记整理算法改进：在标记完成后将存活对象都向内存的一端移动
    * 分代收集算法：根据对象的存活时间划分出永久代（常量、类描述）、老年代和新生代区域，从而针对其特点采用不同的垃圾收集算法（新生代：采用多块内存区域的复制算法，老年代采用标记整理算法）

## 垃圾收集器迭代

串行收集器：单线程，收集时暂停所有工作

并行收集器：

G1收集器：

CMS收集器：

## 机制

* 通过垃圾收集器**周期性**地释放无用对象的内存

* 内存不会泄露但其他资源可能会泄露

* 在自动垃圾回收前系统会自动调用对象的finalize()方法，用于释放资源

* 多对象回收的finalize()方法是随机无次序执行的

* 垃圾收集器自动扫描对象的动态内存区，对无用对象进行标记

* 垃圾收集器是一个后台守护线程

## 内存

方法区：持久带permanent space：主要存放JAVA类定义信息，如方法定义、class对象、常量、静态变量等，与GC关系不大

> 用于存放静态类型数据，如 Java Class, Method 等。持久代对垃圾回收没有显著影响。但是有些应用可能动态生成或调用一些Class，例如 Hibernate CGLib 等，在这种时候往往需要设置一个比较大的持久代空间来存放这些运行过程中动态增加的类型。

Heap space：分为老年代、新生代

年轻代

所有新生成的对象首先都是放在年轻代。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代一般分3个区，1个Eden区，2个Survivor区（from 和 to）。

大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当一个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当另一个Survivor区也满了的时候，从前一个Survivor区复制过来的并且此时还存活的对象，将可能被复制到年老代。

2个Survivor区是对称的，没有先后关系，所以同一个Survivor区中可能同时存在从Eden区复制过来对象，和从另一个Survivor区复制过来的对象；而复制到年老区的只有从另一个Survivor区过来的对象。而且，因为需要交换的原因，Survivor区至少有一个是空的。特殊的情况下，根据程序需要，Survivor区是可以配置为多个的（多于2个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。

针对年轻代的垃圾回收即 Young GC。

年老代

在年轻代中经历了N次（可配置）垃圾回收后仍然存活的对象，就会被复制到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。

针对年老代的垃圾回收即 Full GC。


