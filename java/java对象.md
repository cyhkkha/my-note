<font size="4">

# java对象

by 菲尼莫斯 2019年3月14日

---

## 面向对象的特性

### 抽象

* 忽略与当前目标无关的方面，只关注与当前目标有关的内容

> 如将代码中重复的或具体的部分提取为一个组件（抽象为一个对象）

* 抽象类abstract不能实例化，只能被用于extends

### 封装

* 将抽象对象的数据和数据操作的方法进行隐蔽

* 对外提供接口给使用者，使用者不必知道内部实现细节和存储细节

* 将设计者和使用者分开

### 继承

* 子类可以获得父类的所有**方法**和**变量**

* 子类可以修改继承的方法和新增方法

* 解决可重用性，提高编码效率和可维护性

* 一个子类只能继承一个父类（**单继承**）

* final类不能继承

### 多态

1. 子类能够响应发送给父类的同名消息

2. 子类可以以与父类不同的行为响应该消息

3. 该特性主要是通过子类覆盖父类方法来实现的 (实现接口、@Overwrite)

## 权限相关

* 默认（包保护）：只能被同一包的方法访问（不同包的子类无法访问）

* public：可以被任意方法访问

* protected：只可被同一类及其子类访问

* private：只可以被同一类的方法访问（子类无法访问）

## 特殊关键字

* 默认：实例变量

* static：静态成员变量（类变量，可在实例间共享，只有一个值）

* transient：非序列化变量，不进行保存

* volatile：共享变量

* abstract：抽象方法

* native：集成java代码和其他语言代码

* synchronized：控制多个并发线程对共享数据的访问

## 方法

* this指向了类本身，可以通过this.访问自身属性，使用this()直接调用类中的构造方法

* supper指向了父类，可以通过supper.访问父类属性，使用supper()调用父类的构造方法

* final实例变量（普通变量）需要在构造方法执行结束前完成初始化

* 子类中的属性会**隐藏**父类中的同名属性
    * 此时只有继承到的方法可以显式访问被隐藏的属性

* 子类中的方法会**覆盖**父类中的同名方法
    * 子类的方法不能比父类的更严格，如public方法不能变为private方法
    * static 和 final 方法不能覆盖
    * 依然可以使用 supper 访问被覆盖的方法

* 抽象方法abstract只有抽象类才能包含，必须被重写（覆盖），该做法规定了子类的规范

## Object类

* getClass()、toString()

* equals(Obj obj)：比较两个指针是否指向同一处；== 运算符也判断**指针**是否指向同一处

* clone()：返回对象的副本（重新申请的对象空间）
    * 默认为protected方法，需要重写为public
    * 使用该功能需要implement Cloneable接口

* hashCode()：对象的唯一标示hash值

* finalize()：回收对象时的资源释放

## 泛型

详见 /code/java/GenericTest.java

</font>