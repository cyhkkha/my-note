<font size="4">

# 周报1227

by 菲尼莫斯 2018年12月27日

---

## 阅读《深入理解es6》

## 字符串的操作

* 码元操作
    * 对于js中的utf-16来说，一个字符可能是16位（1个码元）或是32位（2个码元）
    * String.charCodeAt() : 返回指定字符的码元
    * String.codePointAt() : 返回指定码元位置的码元
    * String.fromCodePoint() : 将某个码元提取为字符

* String.includes( {search}, {start} ) : 在给定文本存在于字符串中的任意位置时会返回 true ,否则返回false

* String.startsWith( {search}, {start} ) & endsWith( {search}, {start} ) : 在给定文本出现在字符串起始处&结尾处时返回 true ,否则返回 false

* String.repeat( {times} ) : 返回一个将String重复times次的字符串

* 获取未被转义的模版字符串 : String.raw()

```js
let m1 = `Happy \n Lucky \n Smile \n Yeah`
console.log(m1); 
// "Happy \n Lucky \n Smile \n Yeah"

let m2 = String.raw`Happy \n Lucky \n Smile \n Yeah`
console.log(m2);
/*
"Happy
 Lucky
 Smile
 Yeah"
*/
```

## 函数

* 块级作用域的函数
    * 块级函数指的是在if块，for块等位置声明的函数
    * 在严格模式下，在块中声明的函数拥有块级作用域
    * 在非严格模式下，块中声明的函数会被提升至块的上一个合法的作用域

* 对箭头函数this的再次明确：
    * 普通函数的this在调用时进行绑定
    * 箭头函数的this永远指向代码编写时声明函数的上下文

* 创建动态函数

## 

```js
let temp = 666;

var add = new Function("a", "b", `return a + b + ${temp}`);

console.log(add(1, 1)); // 2

var pickFirst = new Function("...args", "return args[0]");

console.log(pickFirst(1, 2, 3, 4)); // 1

```

## 一些新方法

* Array.map(fnc(){return newItem}) : function内的返回值将组成一个新的数组

* Array.sort(fnc(a,b){return c})
    * c < 0 则a排在b前面
    * c > 0 则b排在a前面
    * c = 0 则a和b的相对位置不变

## 关于Unicode字符串的解释和浏览器实现的出入

书中的代码：

```js
var text = "a" ;

console.log(text.charCodeAt(0)); // 55362

console.log(text.charCodeAt(1)); // 57271

console.log(text.charCodeAt(2)); // 97

console.log(text.codePointAt(0)); // 134071

console.log(text.codePointAt(1)); // 57271

console.log(text.codePointAt(2)); // 97
```

chrome中的实现：

```js
var a = 'a'

a.charCodeAt(0) // 97

a.charCodeAt(1) // NaN

a.codePointAt(0) // 97

a.codePointAt(1) // undefined
```

书中解释为由于js使用UTF-16，其第一个2代码点表示单个16位码元，这个范围被称为多语言基本平面（BMP），任何超出该范围的代码点都不能用单个 16 位码元表示，而是会落在扩展平面内。这个 Unicode 字符"a"使用了代理对，因此，上面的 JS 字符串操作会将该字符串当作三个16 位字符来对待，这意味着：charCodeAt(0)以及charCodeAt(1)的值为一个不可打印的字符。

codePointAt()方法的返回值一般与charCodeAt()相同，除非操作对象并不是 BMP 字符。a字符串的第一个字符不是 BMP 字符，因此它占用了两个码元，意味着该字符串的length属性是 3 而不是 2 。charCodeAt()方法只返回了位置 0 的第一个码元;而codePointAt()返回的是完整的代码点，即使它占用了多个码元。对于位置 1 (第一个字符的第二个码元)和位置 2 ("a"字符)来说，两个方法返回的值则是相同的。

而在chrome中的浏览器实现则明显忽略了第一个utf-16的码元，直接给出了表示字符的码元

## promise 用法

### 基本概念

> Promise 对象用于一个异步操作的最终完成（或失败）及其结果值的表示。简单点说，它就是用于处理异步操作的，异步处理成功了就执行成功的操作，异步处理失败了就捕获错误或者停止后续操作。

* Promise示例接受一个执行函数

* 在执行函数中：调用resolve()将该实例的状态置为fulfilled，即已完成的，如果失败，可以调用reject()将该实例的状态置为rejected，即失败的

* Promise对象含有then方法，then()调用后返回一个Promise对象，意味着实例化后的Promise对象可以进行链式调用，而且这个then()方法可以接收两个函数，一个是处理成功后的函数，一个是处理错误结果的函数。

### 常规用法

```js
new Promise(
    function(resolve, reject) {

        /* **业务代码** */

        // 业务成功时执行resolve()
        resolve(success返回值)
        // 业务失败时执行reject()
        reject(failed返回值)
    }
).then(
  function(success返回值){
    // 若promise中resolve执行成功，则运行此处
  },
  function(failed返回值){
    // 若promise中reject执行成功，则运行此处
  }
).then(...)
```

### then的链式调用

then默认的执行状态为成功（即resolve或fulfilled）

then接收的值为最近一次调用resolve或reject的赋值

```js
var promise2 = new Promise(function(resolve, reject) {
  // 2秒后置为接收状态
  setTimeout(function() {
    resolve('success');
  }, 2000);
});

promise2
  .then(function(data) {
    // 上一个then()调用了resolve，置为fulfilled态
    console.log('第一个then');
    console.log(data);
    return '2';
  })
  .then(function(data) {
    // 此时这里的状态也是fulfilled, 因为上一步返回了2
    console.log('第二个then');
    console.log(data);  // 2

    return new Promise(function(resolve, reject) {
      reject('把状态置为rejected error'); // 返回一个rejected的Promise实例
    });
  }, function(err) {
    // error
  })
  .then(function(data) {
    /* 这里不运行 */
    console.log('第三个then');
    console.log(data);
    // ....
  }, function(err) {
    // error回调
    // 此时这里的状态也是fulfilled, 因为上一步使用了reject()来返回值
    console.log('出错：' + err); // 出错：把状态置为rejected error
  })
  .then(function(data) {
    // 没有明确指定返回值，默认返回fulfilled
    console.log('这里是fulfilled态');
});
```


### 一些细节

* then()、catch()会自动返回一个promise对象

* then()或catch()的返回值

    * 无返回值：自动返回一个成功状态的无传递参数的promise

    * promise对象：返回该promise对象

    * 非promise对象：返回成功状态的promise，并将传递参数置为该值

    * throw err：返回失败状态的promise，并将传递参数置为err


</font>
