<font size="4">

# 算法基础

by 菲尼莫斯  2019年02月19日

---

## 数据结构

### 链表

```js
class LinkNode {
    value = null;
    next = null;
    getLast() {
        let last = this;
        while (last.next) {
            last = last.next;
        }
        return last;
    }
    push(value) {
        const temp = new LinkNode();
        temp.value = value;
        this.getLast().next = temp;
    }
}
```

### 二叉树

深度为k的完全二叉树：

* 第k-1层节点数达到最大，整棵树无单独的右子节点

1. 第i层（i ≠ k）： 具有2 <sup>i-1</sup> 个节点

2. 最多具有2<sup>k</sup>-1个节点

3. 度（孩子数）为0的节点是度为2的节点的两倍

4. n个节点的完全二叉树有 n/2 + n mod(2) 个叶子节点

* 将完全二叉树按照从上到下，从左到右，从1开始编号则有：

1. 编号为i的节点的父节点编号为i/2（向下取整）

2. 编号为i的节点的左子节点编号为2i

### 堆（大顶堆，小顶堆）

### 栈

### 向量

### 表（Hash）

## 算法

* 搜索（广度、深度）

* 递归

* 二分查找

* 排序（归并、快排、冒泡）

* 树的增删改查遍历

* 图论

* Hash算法

* 分治法（模块化）

* 动态规划

## 系统设计

* 不涉及高并发的大规模分布式系统技术：

谷歌的GFS、MapReduce、Bigtable技术（Hadoop、HBase、HDFS、Cassandra）

* 传统大规模分布式系统：

database + sharding（分片） + cache

sharding的水平分片和垂直分片

cache的同步和异步更新

* 数据库：

SQL：MySql、SqlServer、oracle

NoSql：Redis/TFS、monogoDB、levelDB

## 链表判环

1. 设置一个块遍历fast，一个慢遍历slow

2. fast每次移动2步，slow每次移动1步

3. 若fast和slow最终相交则证明有环存在

4. 从链表头设置一个新遍历its

5. its每次移动1步，slow继续遍历每次移动1步

6. its和slow必相交，且交点为环的入口点

* 引申： 判断两条链是否相交，并找到交点： （将链尾连到链头形成环）

</font>