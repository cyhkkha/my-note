# 对象创建模式

by 菲尼莫斯 2019年3月26日

---

## 单例模式：

保证一个类只有一个实例，并提供该实例的全局访问点（数据库连接池、datasource、日志控制）

用于在构建一个实例时需要消耗大量资源的场景

优点：
* 只维护一个实例，可以大大减少系统的开销
* 由于只有一个实例，因此共享资源的访问更为方便和高效

实现模式：
* 在加载类的时候就创建好实例，具有最高的效率，但导致不能延迟加载
* 在使用类时随即创建实例，并只维护这一个实例，由于创建实例的过程会导致非线程安全，因此会在创建时降低并发效率

懒加载：
* 由于类加载是线程安全的，因此可以用内部类来解决创建单例实例时的非线程安全问题
* 注意在外部类加载时内部类不会立即被加载，因此能够实现单例模式的懒加载

```java
class Instance {
    static class inner {
        private static final Instance = new Instance();
    }
    private Instance() {}
    // 唯一能获得实例的方法
    public static Instance getInstance() {
        return inner.instance;
    }
}
```

## 工厂模式

实现创建者和调用者的分离，实现面向对象的分工分离

* OCP开闭原则：实体应对扩展开放对修改关闭；即扩展时不需要修改原有代码；

* DIP依赖反转原则：针对接口编程，不要针对实现编程；调用由具体的实体转变为抽象的实体

* LoD（Demeter原则）：只与相关的类进行通信，避免和未知类通信

简单工厂模式：建立一个对象的接口，通过一个专门的工厂类来创建对象。该方法每次添加新对象时，需要对工厂的代码进行修改，不符合OCP原则，但十分简单，适合对创建对象前做一些初始化配置

```java
interface Band {
    public void dispaly();
}
class BandSchool {
    public static Band createSimpleBand(String name) {
        return new Band(){
            @Override
            public void dispaly() {
                System.out.println(name + " is displaying");
            }
        };
    }
}

```

工厂方法模式：对象和对象工厂分别建立一个接口，每次添加新对象时，需要同时实现对象和对象的工厂。该方法满足设计模式但更为复杂和难于管理，因此常用简单工厂模式


抽象工厂模式：适合针对产品族的设计，即多子产品和不同业务由一套规则生产。一个工厂接口可以生产不同产品族，但不能增加产品种类

## 建造者模式

构建复杂的产品，该产品包含各类复杂的子产品部件，并需要进行装配；通常子产品由工厂模式创建，建造者则装配这些产品。

Builder接口负责构建子产品、Director接口负责组装Builder的构建的产品

## 原型模式

以已存在的对象作为原型，通过增添或修改其细节等，达到快速构建并适应当前情景的目的

new对象是重新构建对象，并重新赋给默认值，原型则是直接对原型进行拷贝

* 原型接口需要实现Cloneable空接口作为JAVA克隆规范一个标志位

* 对于父对象的引用属性A和克隆对象的引用属性B来说，浅克隆只将A这个指针值复制给了B，实际上指向的是同一块内存；深克隆则将A指针指向的内容在内存中拷贝了一份，A和B的值不一样，但指向了有相同结构和数据的不同内存。
