# 线程锁

by 菲尼莫斯 2019年4月16日

---

## 悲观锁和乐观锁

### 悲观锁：

每次进行**读写**操作都认定会发生冲突，因此会对数据进行加锁，其他线程读取时都会进入阻塞

如synchronized和ReentrantLock

### 乐观锁：

读取数据时直接读取，但在更新时加锁或使用用CAS等方式进行判断是否该更新，若更新失败则重新更新直到成功

如atomic包下的所有包装类

## 重入锁 ReentrantLock：

* 在同一个线程中可以重复加锁，只需要解锁同样的次数就能真正解锁。

```java
ReentrantLock Lock = new ReentrantLock();
Condition condition = lock.newCondition();
// 加一把锁
Lock.lock();
// 相当于wait()，程序会立即释放锁
condition.await();
// 相当于notify()
condition.signal();
// 解一把锁
lock.unlock();
```

* 使用ReentrantLock类实现线程锁来代替synchronized可以使程序的逻辑性更灵活，在早期java版本运行的效率更高

* 等待锁阻塞的中断，即线程在阻塞并等待锁时，如被中断则会抛出InterruptedException异常，**并结束等待锁的阻塞状态继续执行**，若要实现这种操作应使用`lock.lockInterruptibly()`进行加锁。

* 判断是否需要等待锁：
    * `lock.tryLock(2, TimeUnit.SECONDS)`：判断从现在起两秒的时间内是否要一直等待锁，返回值为boolean。
    * `lock.tryLock()`：判断当前是否要等待锁。返回值为boolean

## 公平锁：

* cpu对线程的调度室随机的，同样对锁的分配也是随机的，因此一个线程刚释放锁可能又可以立即获得锁

* 公平锁能够按申请顺序进行锁分配

```java
// 传入true可以使重入锁变为公平锁
ReentrantLock lock = new ReentrantLock(true);
// 此时将维护一个有序队列记录申请锁的排队顺序
```

## 偏向锁：

> 偏向锁是JDK1.6提出来的一种锁优化的机制。其核心的思想是，如果程序没有竞争，则取消之前已经取得锁的线程同步操作。也就是说，若某一锁被线程获取后，便进入偏向模式，当线程再次请求这个锁时，就无需再进行相关的同步操作了，从而节约了操作时间，如果在此之间有其他的线程进行了锁请求，则锁退出偏向模式。

* 偏向锁在线程对资源竞争较为激励的程序中反而会降低性能

## 自旋锁：

在线程所申请的锁处于占用状态时，线程会运行一个空循环，从而使得线程不被挂起，而是循环一定时间后再次去获取锁，从而加强了线程执行的连贯性。

* 对于单线程需要长时间占用锁的并发程序，自旋锁反而会造成CPU资源的浪费

* 从1.7开始，JVM会自动将自动分配锁的形式，优先执行自旋锁并自动调整自旋次数，锁的使用顺序如为：偏向锁 -> 轻量级锁 -> 自旋锁 -> 重量级锁

## 轻量级锁：

每个对象都具备markword条目，它记录了锁的标志位：

* 00：处于轻量级锁中，条目指针指向获得轻量级锁的线程栈的备份markword

* 10：处于重量级锁中，条目指针指向重量级锁

* 01：无锁或处于偏向锁中，条目指针存储了对象的相关信息

* 11：被GC所标记

使用轻量级锁的线程一般按以下操作来进行：

1. 检查对象的markword锁标志位是否为01，如不为01则进行其他操作

2. 线程首先将该对象的markword在自己的栈中进行备份，并不断地尝试将markword的标志位置为00，将markword的指针指向自己的备份。

3. 若指针更改成功则会进行CAS操作，若CAS操作失败，则检查markword的指针是否还指向自己的栈的备份。若还在自己的栈，则继续进行CAS。

4. 若已经不指向自己的栈，那证明已经有并发程序竞争，此时则将markword的锁标志位记为10，则之后的其他并发都将采用自旋锁或重量级锁

5. 之后线程自身将采用自旋锁来等待并获取锁

关于CAS：

> CAS指令需要三个操作数，分别为内存位置（在java中可以理解为变量在内存中的位置，用V标识）、旧的预期值（用A标识）、新值（用B 标识）。当CAS指令执行的时候，当且仅当V符合预期值A，处理器才会使用新值B更新V，否则他就不执行更新，但是是否更新了V，都会返回V的旧值，而且这一系列的操作过程都是原子性的。

## 读写锁

即在同时执行读操作时，可以让不同线程间非阻塞地运行，从而有效地减少锁的竞争。

```java
ReadWriteLock lock = new ReentrantReadWriteLock();
Lock readLock = lock.readLock();
Lock writeLock = lock.writeLock();
// 其他使用方式同重入锁
```

## 分段锁

参考ConcurrentHashMap的实现，即对于HashMap中entry数组的操作，除了在扩容时，其他时间并不会改变entry数组容量或调换元素，因此只需对每个元素进行加锁，即可减少并发存取Map造成的阻塞时间。
