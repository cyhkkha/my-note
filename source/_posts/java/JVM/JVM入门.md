---
title: JVM入门
author: 菲尼莫斯
date: 2019-03-18
tags:
- jvm
categories:
- java
---

# JVM入门

by 菲尼莫斯 2019年3月18日

---

## 基本

* jdk是java的开发工具包，包含了java编译器，可以将.java文件编译为.class字节码文件，以及一些其他的开发工具（如 web server）

* jre是java的运行环境，jdk中包含了jre，是执行java必须的一部分，包含jvm、基本类库、配置和java的执行命令等

* jvm是java运行时所存在的环境，是为java语言深度优化的虚拟硬件模拟软件，拥有处理器、指令系统、堆栈和寄存器

## 内存分区

Java栈：即虚拟机栈，是Java方法执行的内存模型，每一个栈帧对应着一个被调用的方法
* 局部变量表：对于基本数据类型的变量，则直接存储它的值，对于引用类型的变量，则存的是指向对象的引用，局部变量表的大小在编译器就可以确定其大小
* 操作数栈：用于进行操作数计算
* 指向运行时常量的引用
* 方法返回地址，即方法执行完毕后返回调用的地方

本地方法栈：执行native方法使用的栈

方法区（永久带）：类信息（Class类中的内容）、静态变量、常量、编译后的代码
* 常量池：**字面量常量**、符号引用

堆：存储对象本身和数组本身，包括其中的基本类型的具体数值、对象或数组中的引用类型的指针值（在外部对象和数组指针引用是存放在栈中）

程序计数器：保存了当前执行指令的地址，每个线程都有独立的程序计数器

## 类加载的过程

类的加载：JVM把class文件加载到内存，对数据进行校验、解析和初始化，最终形成JVM可以直接使用的类型

1. 加载：使用**类加载器**将字节码的内容加载到内存中
    * 将静态的数据转换为**运行时数据**存入JVM内存的**方法区**（方法区位于堆中）
    * 运行时数据包括：静态变量（域）、静态方法、类代码、常量池（方法名、参数类型、变量名）
    * **未进行主动引用（通常是字面量）生成的基本类型或String的static常量**将在此时被初始化并写入方法区的常量池
    * 在堆中生成一个该类Class对象，作为方法区数据的访问接口
    * 字节码的来源可以是.class文件、jar包或者其他方式读取
    * 一般来说类只要加载并能在内存中维持一段时间，但也会被GC所回收

2. 连接：将类的字节码合并到JVM的运行时状态中
    * 验证：确保类符合JVM规范，语法正确，没有安全问题
    * 准备：为静态变量的数据分配内存并设置默认值（**0，或者null**）并存入**方法区**
    * 解析：将方法区中常量池的符号引用替换为直接引用，包括类名、变量名、字面量等。
    * （解析：即将源码中的字面量符号替换成引用的对象，如`int a = 22`变换为`int类引用信息地址 a变量名引用地址 = 22字面量引用地址`）

3. 初始化：执行类构造器`<clinit>()`方法，在对类主动引用时才进行初始化
   * 类构造器方法是**编译器**收集并合并类中**静态变量**的赋值和**static代码**块所产生的初始化方法，该方法生成到.class中
   * 若父类没有初始化，则会**先对父类进行初始化**
   * 类构造器方法无法自己定义，是编译器自动产生并由JVM调用的，该方法是一个静态方法，保存在方法区中
   * 该方法是线程安全的
   * 该方法只运行一次，是在类第一次被**主动引用**到的时候被触发
   * **非静态的变量或常量**将在new一个对象时进行初始化（每个实例的非静态常量可以不一样）
   * **初始化时不会初始化内部类，只有在访问到内部类域的属性时才会初始化**

### 类的引用

会触发类的初始化的**主动引用**方式:

* new一个实例
* 直接调用静态成员和静态方法
* 直接调用特殊的static final常量
    * **基本类型和String以外**的所有static final常量
    * 主动引用其他类而生成的static final常量
* 加载类的反射Class对象
* main方法所在的类在虚拟机启动时一定会被引用和初始化
* 子类初始化时对父类构造函数的引用

不会触发类的初始化的**被动引用**方式

* 通过子类引用父类的静态变量不会导致子类被初始化
* 定义类的数组
* 引用非主动引用方式生成的基本类型和String类型

## 类加载器

基本作用：

* 根据一个指定的类名，找到或者生成对应的字节码，定义出一个运行时的Java类，实现一个Class实例；

* 加载Java运用程序所需的资源，包括图像、配置文件和其他语言文件等；

加载器类型：

* 引导类加载器：使用c++或其他原生代码实现，加载java的核心库，加载其他的加载器
* 扩展类加载器：使用Java实现，用于加载Java扩展库，继承自ClassLoader类和引导类加载器
* 应用程序加载器：记载Java应用的相关类，继承自扩展类加载器类
* 自定义加载器：加载自定义类，继承自应用程序加载器

双亲委托加载模式：

* 当子加载器要加载一个类是，必须一层一层上报父加载器，若父加载器能够加载则加载父加载器下的该类，否则才能由子加载器加载。

* **优点**：保证关键类能够被父加载器加载，而不会被子加载器覆盖；保证所有类只加载一次，并由同一个加载器加载。
*
* **缺点**：JDBC等由Java核心定义的接口的第三方实现类不能被正常加载

* tomcat采用和双亲委托机制完全相反的模式，且为每个webApp分配一个独立的类加载器

其他：

* [Class c].getClassLoader()可以获得加载该类的类加载器

* 不同加载器加载的同一个类，JVM认为是不同的类

* 使用Thread.currentThread().setContextClassLoader(ClassLoader cl)：可以临时改变当前线程的类加载器，从而回避一些双亲委托机制带来的问题

## 其他

* 每个java程序使用一个java虚拟机

* 虚拟机的运行开始于main()方法，为程序的初始线程且不为守护线程

* 在对应权限下调用exit()方法能够终止程序执行

* 类加载子系统（class loader）负责加载类和接口
    * 类和接口是在第一次使用的时候被动态加载进JVM的，如创建了一个对该类静态成员的引用

* 执行引擎（execution engine）负责执行加载类中的指令

* 内存分配
    * 线程共享区：方法区（常量、静态变量、类信息、.class字节码）、堆（存储对象实例）
    * 线程私有：虚拟机栈（类的方法调用）、本地方法栈（非java方法调用）、程序计数器（行数）

* 类的加载和链接是在运行时进行的：loading（运行时数据结构）、verification（规范、版本、安全等）、preparation（分配内存、常量初始化）、resolution（符号引用转为直接引用）、initialization（类变量）、using（主被动引用）、unloading（卸载）


