# js事件

by 菲尼莫斯 2019年3月29日

---

## 事件流

* 事件捕获阶段
    * 从最顶层元素doucment -> html -> body -> ... -> 触发元素的父级

* 事件冒泡阶段
    * 从触发元素 -> 触发元素父级 -> ... -> body -> html ->document
    * 最底层元素不会触发事件捕获，只触发冒泡

## 事件触发

* 从html捕获：`on[事件名]` 用在html元素上
    * `<input type="button" onclick="console.log(event, this, type)" />`
    * 会生成一个封装元素属性的函数和作用域，该作用域包含`event事件`局部变量，`this`指向该html对象，`this`中的属性可以直接使用，就如同`with(this){}`

* （DOM0）从document中获取该元素的对象，添加`on[事件名]`名的函数，该函数和html事件直接写入的函数相同
    * 使用getElementById等方法获取元素
    * 通过设置null移除监听

* （DOM2）使用观察者模式监听并截获事件
    * 从document中获取元素对象，通过`元素.addEventListener(事件名，事件函数，事件阶段)`添加监听器
    * 事件阶段：true（捕获阶段）、false（冒泡阶段）
    * 通过removeEventListener移除监听
    * 事件函数：该函数和html事件直接写入的函数相同

* 使用event.stopPropagation()阻止向上冒泡和向下捕获

* 使用event.preventDefault()阻止默认事件，使用事件响应函数return false阻止默认事件

## 事件循环

js代码是在**主线程**中单线程执行的，一个事件周期只能执行一个js函数，因此异步的事件和回调被分配到了之后的个事件周期

js运行时，只有在当前执行栈的代码运行完毕，即栈为空时，才会去读取异步和回调地事件，这些存储这些事件的容器为**任务队列**

**注意：**只有js的运行是单线程的，但其他的系统级操作是多线程的，这些线程称为**工作线程**，如IO操作，定时器，ajax，DOM渲染等

### js运行过程如下：

1. 主线程的栈内压入入口程序的代码

2. 遇到**异步任务**时，异步任务会添加到**任务队列**中，主程序接着往下运行。

3. 遇到**IO任务**时，IO任务由**工作线程**运行，主程序接着往下运行。当IO操作运行完成时，其**回调函数**将添加到任务队列中

4. 主程序运行完毕，执行栈为空，此时js会去循环地查询任务队列，任务按先进先出被取出。

5. 执行栈按顺序压入各个异步任务和回调函数，依次执行。

6. 注意：遇到**定时器**时，则是交由工作线程计时，时间到后之后将定时器地回调函数添加到任务队列中。由于系统要执行完主程序以及已有的任务队列，才会去运行定时器的回调，因此定时器不一定准确。

### 宏任务队列与微任务队列

任务队列的分类是在es6以后出现的

宏任务队列是**全局的**任务队列可以有多个：包括**计时器**、**IO**和**ajax**等

**浏览器会在每个宏任务周期间渲染页面**

微任务队列只有一个，如Promise的异步任务

**微任务是一次执行所有的**，当每次执行栈清空时，以及每次宏任务执行完毕时。
